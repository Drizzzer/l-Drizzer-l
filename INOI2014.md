---
title: Free Ticket
authors:
- Shreyash Verma 
---

### Problem statement in brief:-
- There are C number of cities and we can travel from one city to another by a flight.
- All cities can be reached from each other by some sequence of connecting flights.
- Each direct flight between two cities has a fixed price.
- You are given the information of cost of each direct flight.
- You have to find the maximum cost among the cheapest routes between all pairs of cities across the airline’s network.
### Input Details:-
- Line 1 : Two space-separated integers, C and F . C is the number of cities on the network and F is the number of pairs of cities connected by a direct flight
- Lines 2 to F + 1 : Each line describes one direct flight between a pair of cities and consists of three integers, x, y and p, where x and y are the two cities connected by this flight and p is the price of the flight.

**Note:-** For all direct flights, $$x≠y$$, and no pair of cities is connected by more than one direct flight. If there is a direct flight from x to y with price p, there is also a flight from y to x with price p and exactly one of these two will be listed.

### Subtask 1 [20 points]:-  $$F=C−1$$, (The airline network is a tree).
In this subtask, the airline network is a tree.

This subtask can be solved by simple depth-first search for calculating the price to travel from one city to another and comparing the prices of all pair of cities and finding the maximum price.

<details>
<summary>Code for this subtask: </summary>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 231;
vector<pair<int,int>> arr[N]; //declaring the tree
bool vis[N]; // declaring an array for checking weather the node is visited or not.
int ans = 0; // Declaring the answer.

// DFS for calculating the price from one node to other node.
void dfs(int last_ans, int curr_node){
    if(vis[curr_node]) return; //checking weather the node is visited or not.
    vis[curr_node] = 1; // declaring that the node is visited.
    for(auto elem:arr[curr_node]){
        dfs(last_ans+elem.second, elem.first);
        // dfs for calculating the price from the starting node to each node.
    }
    ans = max(ans, last_ans); //Finding the maximum price.
}

int main()
{
    int c,f;
    cin>>c>>f;
    //Taking input of the tree.
    for(int i=0;i<f;i++){
        int x,y,p;
        cin>>x>>y>>p;
        arr[x].push_back({y,p});
        arr[y].push_back({x,p});
    }
    //running dfs from each node to check price of all pairs of node.
    for(int i=1;i<=c;i++){
        memset(vis,0,sizeof(vis));
        dfs(0, i);
    }
    cout<<ans<<"\n"; //printing the answer.
}

```
</details>

Time Complexity: $$O(C * (C+F))$$

### Subtask 2 [30 marks]:- There is no constraint on the shape of the network, but for each direct flight, $$p = 1$$.

In this subtask, the price of each flight is 1.

This subtask can be solved by simple breadth first search for calculating the minimum price between two cities and comparing the distance of all pair of cities and finding the minimum price as the price can also be used as distance between two cities.

<details>
<summary>Code for this subtask: </summary>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 231;
const int melem = 1e5+1;
vector<pair<int,int>> arr[N]; //declaring the graph
vector<int> dis(N, melem); //making vector for storing distance between two cities

int main()
{
    int c,f;
    cin>>c>>f;
    set<pair<int,int>> mn_dis; //storing minimum distance between two nodes
    mn_dis.insert({0,1});
    //Taking input of the graph
    for(int i=0;i<f;i++){
        int x,y,p;
        cin>>x>>y>>p;
        arr[x].push_back({y,p});
        arr[y].push_back({x,p});
    }
    dis[1] = 0;
    //Running BFS to store minimum all distances between all pair of cities
    while(!mn_dis.empty()){
        auto elem = *(mn_dis.begin());
        mn_dis.erase(mn_dis.begin());
        int dist=elem.first,node=elem.second;
        for(auto &node2:arr[node]){
            if(dis[node2.first]>(dist+node2.second)){
                if(mn_dis.find({dis[node2.first],node2.first})!=mn_dis.end())
                mn_dis.erase(mn_dis.find({dis[node2.first],node2.first}));
                dis[node2.first] = dist + node2.second;
                mn_dis.insert({dis[node2.first],node2.first});
            }
        }
    }
    int ans = 0; //declaring the answer
    //Finding the maximum of minimum distances between all pair of cities.
    for(int i=0;i<=N;i++){
        if(dis[i]!=melem)
        ans = max(ans, dis[i]);
    }
    cout<<ans<<"\n"; //printing the answer
    return 0;
}
```
</details>

Time Complexity: $$O(C*(C+F))$$

### Subtask 3 [50 marks]:- There is no constraint on the shape of the network, but for each direct flight, $$0 ≤ p ≤ 10^5$$.

In this subtask, the price of each flight is less than $10^5$

This subtask can be solved by Floyd Warshall which find the shortest distances between every pair of vertices in a given edge weighted directed Graph. Here weight of graph is price of each flight.

You can read more about the Floyd Warshall Algorithm here - 
[Shortest Path Algorithms](https://training.ufds.cc/stages/1-Syllabus/6-Basic-Graph-Theory/7-Shortest-Paths)

<details>
<summary>Code for this subtask: </summary>
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e7+10;

int main(){
    
    int arr[232][232]; //Declaring 2-D array to store distances between all pair of cities.
    //Initialising the array.
    for(int i=1;i<=230;i++){
	    for(int j=1;j<=230;j++){
	         if(i==j)
	         arr[i][j] = 0;
	         else
	         arr[i][j] = INF;
	    }
	}
	int n,m;
	cin>>n>>m;
        //Taking input of the graph.
	for(int i=0;i<m;i++){
	    int x,y,wt;
	    cin>>x>>y>>wt;
	    arr[x][y] = wt;
	    arr[y][x] = wt;
	}
	//Applying Floyd Warshall algorithm.
	for(int k=1;k<=n;k++){
	    for(int i=1;i<=n;i++){
	        for(int j=1;j<=n;j++){
	            arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]);
	            arr[j][i] = arr[i][j];
	        }
	    }
	}
	int ans = 0;
	//Finding the maximum of cheapest of all the pair of cities.
	for(int i=1;i<=n;i++){
	    for(int j=i;j<=n;j++){
	        ans = max(ans,arr[i][j]);
	    }
	}
	//Printing the answer.
	cout<<ans<<"\n";
	
	return 0;
}
```
</details>

Time Complexity: $$O(C^3)$$

### ***Note*** - The code passing all the subtasks is the same as the code of subtask 3.                  